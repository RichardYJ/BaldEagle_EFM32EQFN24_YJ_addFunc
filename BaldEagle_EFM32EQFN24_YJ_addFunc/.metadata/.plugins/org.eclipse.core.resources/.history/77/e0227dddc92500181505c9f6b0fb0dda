

#include <SI_EFM8LB1_Register_Enums.h>
#include "EFM8LB1_SMBus_MasterMultibyte.h"
#include "EFM8LB1_I2C_Slave.h"



SI_INTERRUPT (I2C0_ISR, I2C0_IRQn)
{


}


SI_INTERRUPT (SMBUS0_ISR, SMBUS0_IRQn)
{
	bool FAIL = 0;
	static uint8_t sent_byte_counter;
	static uint8_t rec_byte_counter;

	if (SMB0CN0_ARBLOST == 0)
	{

		switch (SMB0CN0 & 0xF0)
		{

			case SMB_MTSTA:
			SMB0DAT = TARGET<<1;
			SMB0DAT &= 0xFE;
			SMB0DAT |= (uint8_t) SMB_RW;
			SMB0CN0_STA = 0;
			rec_byte_counter = 1;
			sent_byte_counter = 1;
			break;


			case SMB_MTDB:
			if (SMB0CN0_ACK)
			{
				if (SMB_RW == WRITE)
				{
					if (sent_byte_counter <= nWR /*NUM_BYTES_WR*/)
					{

						SMB0DAT = SMB_DATA_OUT[sent_byte_counter-1];
						sent_byte_counter++;
					}
					else
					{
						SMB0CN0_STO = 1;
						SMB_BUSY = 0;
					}
				}
				else {}
			}
			else
			{
				if(bTx_4th_byte_nack)
				{
					SMB0CN0_STO = 1;
					SMB_BUSY = 0;
					break;
				}
				SMB0CN0_STO = 1;
				SMB0CN0_STA = 1;
				NUM_ERRORS++;
			}
			break;


			case SMB_MRDB:
			if (rec_byte_counter < NUM_BYTES_RD)
			{
				SMB_DATA_IN[rec_byte_counter-1] = SMB0DAT;

				SMB0CN0_ACK = 1;
				rec_byte_counter++;
			}
			else
			{
				SMB_DATA_IN[rec_byte_counter-1] = SMB0DAT;

				SMB_BUSY = 0;
				SMB0CN0_ACK = 0;

				SMB0CN0_STO = 1;
			}
			break;

			default:
			FAIL = 1;
			break;

		}
	}
	else
	{

		FAIL = 1;
	}

	if (FAIL)
	{
		SMB0CF &= ~0x80;
		SMB0CF |= 0x80;
		SMB0CN0_STA = 0;
		SMB0CN0_STO = 0;
		SMB0CN0_ACK = 0;

		SMB_BUSY = 0;

		FAIL = 0;


		NUM_ERRORS++;
	}

	SMB0CN0_SI = 0;
}

SI_INTERRUPT (TIMER3_ISR, TIMER3_IRQn)
{
	SMB0CF &= ~0x80;
	SMB0CF |= 0x80;
	TMR3CN0 &= ~0x80;

	SMB0CN0_STA = 0;
	SMB_BUSY = 0;
}

SI_INTERRUPT (TIMER4_ISR, TIMER4_IRQn)
{
	SFRPAGE = PG3_PAGE;

	I2C0CN0 &= ~I2C0CN0_I2C0EN__BMASK;
	I2C0CN0 |= I2C0CN0_I2C0EN__ENABLED;

	SFRPAGE = PG2_PAGE;
	TMR4CN0 &= ~TMR4CN0_TF4H__BMASK;

}

SI_INTERRUPT (ADC0EOC_ISR, ADC0EOC_IRQn)
{
	   ADC0CN0_ADINT = 0;
	   ADC_AVG = ADC0/4;
	   CONV_COMPLETE = 1;

}

